package main

import (
	"errors"
	"fmt"
	"net"
	"strconv"
)

// Server.
type server struct {
	listeners_requests_errors []func(error)
	listners_requests         []func(*request, *response) error
	sessions                  map[string]*net.Conn
	port                      int
	buffer                    []byte
}

// Create a server.
func server_create(port int) *server {
	return &server{
		listeners_requests_errors: []func(error){},
		listners_requests:         []func(*request, *response) error{},
		port:                      port,
		buffer:                    make([]byte, 1024),
	}
}

// Start the server.
func server_start(self *server) error {
	lis, err := net.Listen("tcp4", ":"+strconv.Itoa(self.port))
	if err != nil {
		return err
	}

	defer func(listener net.Listener) { _ = listener.Close() }(lis)
	for {
		con, err := lis.Accept()
		if err != nil {
			return err
		}
		server_handle_client_socket(self, con)
	}
}

// Handle incoming client socket.
func server_handle_client_socket(self *server, s net.Conn) {
	req := request{
		socket:  s,
		headers: &headers{},
		method:  "",
		path:    "",
		version: "",
	}

	// Order matters.
	// #####################################################################
	m, merror := request_find_method(&req)
	if merror != nil {
		server_notify_error(self, merror)
		_ = s.Close()
		return
	}
	p, perror := request_find_path(&req)
	if perror != nil {
		server_notify_error(self, perror)
		_ = s.Close()
		return
	}
	v, verror := request_find_version(&req)
	if verror != nil {
		server_notify_error(self, verror)
		_ = s.Close()
		return
	}
	h, herror := request_find_headers(&req)
	if herror != nil {
		server_notify_error(self, herror)
		_ = s.Close()
		return
	}
	// #####################################################################

	request_with_method(&req, string(m))
	request_with_path(&req, string(p))
	request_with_version(&req, string(v))
	request_with_headers(&req, h)

	resp := response{
		socket:         s,
		version:        string(v),
		locked_status:  false,
		locked_headers: false,
	}

	err := server_notify_request(self, &req, &resp)
	if err != nil {
		server_notify_error(self, err)
	}
	_ = s.Close()
}

// Register a callback to execute
// whenever the server receives a request.
func server_on_request(
	self *server,
	callback func(*request, *response) error,
) {
	self.listners_requests = append(self.listners_requests, callback)
}

// Collect errors generated by your request listeners.
func server_on_request_error(self *server, callback func(error)) {
	self.listeners_requests_errors = append(self.listeners_requests_errors, callback)
}

func server_notify_error(self *server, err error) {
	for _, listener := range self.listeners_requests_errors {
		listener(err)
	}
}

func server_notify_request(self *server, req *request, res *response) error {
	for _, listener := range self.listners_requests {
		err := listener(req, res)
		if err != nil {
			return err
		}
	}
	return nil
}

type headers map[string]string

// Request.
type request struct {
	socket  net.Conn
	method  string
	path    string
	version string
	headers *headers
}

func request_next_line(self *request) ([]byte, error) {
	var characters []byte
	reader := make([]byte, 1)
	read, read_error := self.socket.Read(reader)

	if read_error != nil {
		return nil, read_error
	}

	for read > 0 {
		if eol == reader[0] {
			return characters, nil
		}

		characters = append(characters, reader[0])
		read, read_error = self.socket.Read(reader)
		if read_error != nil {
			return nil, read_error
		}
	}
	return characters, nil
}

func request_next_section(self *request) ([]byte, error) {
	reader := make([]byte, 1)
	var characters []byte
	var utf8 = ""
	read, read_error := self.socket.Read(reader)
	if read_error != nil {
		return nil, read_error
	}

	for read > 0 {
		if space == reader[0] || eol == reader[0] {
			index := len(characters) - 1
			if characters[index] == cr {
				return characters[:index], nil
			}
			return characters, nil
		}

		characters = append(characters, reader[0])
		utf8 = string(characters)
		println(utf8)

		read, read_error = self.socket.Read(reader)
		if read_error != nil {
			return nil, read_error
		}
	}
	return characters, nil
}

func request_find_headers(self *request) (*headers, error) {
	var key string
	var chunk []byte
	reader := make([]byte, 1)
	headers := make(headers)
	keyed := false
	eols := 0
	read, read_error := self.socket.Read(reader)
	if read_error != nil {
		return nil, read_error
	}

	for read > 0 {
		if eol == reader[0] {
			eols++
			clen := len(chunk)
			if cr == chunk[clen-1] {
				chunk = chunk[:clen-1]
			}
			headers[key] = string(chunk)
			if 2 == eols {
				return &headers, nil
			}

			chunk = []byte{}
			keyed = false
		} else if colon == reader[0] && !keyed {
			key = string(chunk)
			chunk = []byte{}
			keyed = true

			read, read_error = self.socket.Read(reader)
			if read_error != nil {
				return nil, read_error
			}

			if space != reader[0] {
				return nil, errors.New("Invalid header definition. Expecting blank space after `" + key + ":`, received `" + string(reader[0]) + "` instead.")
			}
		} else {
			chunk = append(chunk, reader[0])
		}

		read, read_error = self.socket.Read(reader)
		if read_error != nil {
			return nil, read_error
		}
	}

	return &headers, nil
}

func request_find_method(self *request) ([]byte, error) {
	return request_next_section(self)
}

func request_find_path(self *request) ([]byte, error) {
	return request_next_section(self)
}

func request_find_version(self *request) ([]byte, error) {
	return request_next_section(self)
}

func request_with_method(self *request, method string) {
	self.method = method
}

func request_with_path(self *request, path string) {
	self.path = path
}

func request_with_version(self *request, version string) {
	self.version = version
}

func request_with_headers(self *request, headers *headers) {
	self.headers = headers
}

// Response.
type response struct {
	socket         net.Conn
	version        string
	locked_status  bool
	locked_headers bool
}

// Send the status.
//
// This will lock the status, which makes it
// so that the next time you invoke this
// function it will return an error.
//
// The message defaults to blank.
//
// If the message is left blank,
// an algorithm will try to
// populate it automatically according to the status code.
func status(self *response, status int, message string) error {
	if self.locked_status {
		return errors.New("Status is locked.")
	}
	message_local := message
	self.locked_status = true
	if "" == message_local {
		switch status {
		case 100:
			message_local = "Continue"
		case 101:
			message_local = "Switching Protocols"
		case 102:
			message_local = "Processing"
		case 103:
			message_local = "Early Hints"
		case 200:
			message_local = "OK"
		case 201:
			message_local = "Created"
		case 202:
			message_local = "Accepted"
		case 203:
			message_local = "Non-Authoritative Information"
		case 204:
			message_local = "No Content"
		case 205:
			message_local = "Reset Content"
		case 206:
			message_local = "Partial Content"
		case 207:
			message_local = "Multi-Status"
		case 208:
			message_local = "Already Reported"
		case 226:
			message_local = "IM Used"
		case 300:
			message_local = "Multiple Choices"
		case 301:
			message_local = "Moved Permanently"
		case 302:
			message_local = "Found"
		case 303:
			message_local = "See Other"
		case 304:
			message_local = "Not Modified"
		case 305:
			message_local = "Use Proxy"
		case 307:
			message_local = "Temporary Redirect"
		case 308:
			message_local = "Permanent Redirect"
		case 400:
			message_local = "Bad Request"
		case 401:
			message_local = "Unauthorized"
		case 402:
			message_local = "Payment Required"
		case 403:
			message_local = "Forbidden"
		case 404:
			message_local = "Not Found"
		case 405:
			message_local = "Method Not Allowed"
		case 406:
			message_local = "Not Acceptable"
		case 407:
			message_local = "Proxy Authentication Required"
		case 408:
			message_local = "Request Timeout"
		case 409:
			message_local = "Conflict"
		case 410:
			message_local = "Gone"
		case 411:
			message_local = "Length Required"
		case 412:
			message_local = "Precondition Failed"
		case 413:
			message_local = "Payload Too Large"
		case 414:
			message_local = "URI Too Long"
		case 415:
			message_local = "Unsupported Media Type"
		case 416:
			message_local = "Range Not Satisfiable"
		case 417:
			message_local = "Expectation Failed"
		case 421:
			message_local = "Misdirected Request"
		case 422:
			message_local = "Unprocessable Entity"
		case 423:
			message_local = "Locked"
		case 424:
			message_local = "Failed Dependency"
		case 426:
			message_local = "Upgrade Required"
		case 428:
			message_local = "Precondition Required"
		case 429:
			message_local = "Too Many Requests"
		case 431:
			message_local = "Request Header Fields Too Large"
		case 451:
			message_local = "Unavailable For Legal Reasons"
		case 500:
			message_local = "Internal Server Error"
		case 501:
			message_local = "Not Implemented"
		case 502:
			message_local = "Bad Gateway"
		case 503:
			message_local = "Service Unavailable"
		case 504:
			message_local = "Gateway Timeout"
		case 505:
			message_local = "HTTP Version Not Supported"
		case 506:
			message_local = "Variant Also Negotiates"
		case 507:
			message_local = "Insufficient Storage"
		case 508:
			message_local = "Loop Detected"
		case 510:
			message_local = "Not Extended"
		case 511:
			message_local = "Network Authentication Required"
		default:
			message_local = ""
		}
		if "" == message_local {
			return errors.New("Unknown status code.")
		}
	}
	feed := fmt.Sprintf("%s %d %s", self.version, status, message)
	_, err := self.socket.Write([]byte(feed))
	if err != nil {
		return err
	}
	return nil
}

// Send a header.
//
// If the status has not been sent already, it will be
// This means the status will become locked.
func header(self *response, key string, value string) error {
	if !self.locked_status {
		err := status(self, 200, "OK")
		if err != nil {
			return err
		}
	}

	if self.locked_headers {
		return errors.New("Headers locked.")
	}

	_, err := self.socket.Write([]byte("\n" + key + ": " + value))
	if err != nil {
		return err
	}

	return nil
}

// Send binary safe content.
//
// If the status has not been sent already, it will be sent automatically as "200 OK".
// This means the status will become locked, meaning you cannot set it again.
//
// Headers will be automatically locked, meaning you can no longer set headers after invoking this function.
func send(self *response, value []byte) error {
	if !self.locked_status {
		err := status(self, 200, "OK")
		if err != nil {
			return err
		}
	}

	if !self.locked_headers {
		self.locked_headers = true
		_, err := self.socket.Write([]byte("\n\n"))
		if err != nil {
			return err
		}
	}

	_, err := self.socket.Write(value)
	if err != nil {
		return err
	}

	return nil
}

// Send utf8 content.
//
// If the status has not been sent already, it will be sent automatically as "200 OK".
// This means the status will become locked, meaning you cannot set it again.
//
// Headers will be automatically locked, meaning you can no longer set headers after invoking this function.
func echo(self *response, value string) error {
	return send(self, []byte(value))
}
