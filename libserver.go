package main

import (
	"errors"
	"fmt"
	"net"
	"strconv"
)

type Server struct {
	listenersRequestsErrors []func(error)
	listenersRequests       []func(*Request, *Response) error
	sessions                map[string]*net.Conn
	port                    int
	buffer                  []byte
}

// Create a Server.
func serverCreate(port int) *Server {
	return &Server{
		listenersRequestsErrors: []func(error){},
		listenersRequests:       []func(*Request, *Response) error{},
		port:                    port,
		buffer:                  make([]byte, 1024),
	}
}

// Start the Server.
func serverStart(self *Server) error {
	lis, err := net.Listen("tcp4", ":"+strconv.Itoa(self.port))
	if err != nil {
		return err
	}

	defer func(listener net.Listener) { _ = listener.Close() }(lis)
	for {
		con, err := lis.Accept()
		if err != nil {
			return err
		}
		serverHandleClientSocket(self, con)
	}
}

// Handle incoming client socket.
func serverHandleClientSocket(self *Server, s net.Conn) {
	req := Request{
		socket:  s,
		headers: &Headers{},
		method:  "",
		path:    "",
		version: "",
	}

	// Order matters.
	// #####################################################################
	m, merror := requestNextSection(&req)
	if merror != nil {
		serverNotifyError(self, merror)
		_ = s.Close()
		return
	}
	p, perror := requestNextSection(&req)
	if perror != nil {
		serverNotifyError(self, perror)
		_ = s.Close()
		return
	}
	v, verror := requestNextSection(&req)
	if verror != nil {
		serverNotifyError(self, verror)
		_ = s.Close()
		return
	}
	h, herror := requestFindHeaders(&req)
	if herror != nil {
		serverNotifyError(self, herror)
		_ = s.Close()
		return
	}
	// #####################################################################

	requestWithMethod(&req, string(m))
	requestWithPath(&req, string(p))
	requestWithVersion(&req, string(v))
	requestWithHeaders(&req, h)

	resp := Response{
		socket:        s,
		version:       string(v),
		lockedStatus:  false,
		lockedHeaders: false,
	}

	err := serverNotifyRequest(self, &req, &resp)
	if err != nil {
		serverNotifyError(self, err)
	}
	_ = s.Close()
}

// Register a callback to execute
// whenever the Server receives a Request.
func serverOnRequest(
	self *Server,
	method string,
	path string,
	callback func(*Request, *Response) error,
) {
	self.listenersRequests = append(
		self.listenersRequests, func(request *Request, response *Response) error {
			if method == request.method && path == request.path {
				err := callback(request, response)
				if err != nil {
					return err
				}
			}
			return nil
		},
	)
}

// Collect errors generated by your Request listeners.
func serverOnError(self *Server, callback func(error)) {
	self.listenersRequestsErrors = append(self.listenersRequestsErrors, callback)
}

func serverNotifyError(self *Server, err error) {
	for _, listener := range self.listenersRequestsErrors {
		listener(err)
	}
}

func serverNotifyRequest(self *Server, req *Request, res *Response) error {
	for _, listener := range self.listenersRequests {
		err := listener(req, res)
		if err != nil {
			return err
		}
	}
	return nil
}

type Headers map[string]string

type Request struct {
	socket  net.Conn
	method  string
	path    string
	version string
	headers *Headers
}

func requestNextLine(self *Request) ([]byte, error) {
	var characters []byte
	reader := make([]byte, 1)
	read, readError := self.socket.Read(reader)

	if readError != nil {
		return nil, readError
	}

	for read > 0 {
		if eol == reader[0] {
			return characters, nil
		}

		characters = append(characters, reader[0])
		read, readError = self.socket.Read(reader)
		if readError != nil {
			return nil, readError
		}
	}
	return characters, nil
}

func requestNextSection(self *Request) ([]byte, error) {
	reader := make([]byte, 1)
	var characters []byte
	var utf8 = ""
	read, readError := self.socket.Read(reader)
	if readError != nil {
		return nil, readError
	}

	for read > 0 {
		if space == reader[0] || eol == reader[0] {
			index := len(characters) - 1
			if characters[index] == cr {
				return characters[:index], nil
			}
			return characters, nil
		}

		characters = append(characters, reader[0])
		utf8 = string(characters)
		println(utf8)

		read, readError = self.socket.Read(reader)
		if readError != nil {
			return nil, readError
		}
	}
	return characters, nil
}

func requestFindHeaders(self *Request) (*Headers, error) {
	var key string
	var chunk []byte
	reader := make([]byte, 1)
	headers := make(Headers)
	keyed := false
	eols := 0
	read, readError := self.socket.Read(reader)
	if readError != nil {
		return nil, readError
	}

	for read > 0 {
		if eol == reader[0] {
			eols++
			clen := len(chunk)
			if cr == chunk[clen-1] {
				chunk = chunk[:clen-1]
			}
			headers[key] = string(chunk)
			if 2 == eols {
				return &headers, nil
			}

			chunk = []byte{}
			keyed = false
		} else if colon == reader[0] && !keyed {
			key = string(chunk)
			chunk = []byte{}
			keyed = true

			read, readError = self.socket.Read(reader)
			if readError != nil {
				return nil, readError
			}

			if space != reader[0] {
				return nil, errors.New("Invalid header definition. Expecting blank space after `" + key + ":`, received `" + string(reader[0]) + "` instead.")
			}
		} else {
			chunk = append(chunk, reader[0])
		}

		read, readError = self.socket.Read(reader)
		if readError != nil {
			return nil, readError
		}
	}

	return &headers, nil
}

func requestWithMethod(self *Request, method string) {
	self.method = method
}

func requestWithPath(self *Request, path string) {
	self.path = path
}

func requestWithVersion(self *Request, version string) {
	self.version = version
}

func requestWithHeaders(self *Request, headers *Headers) {
	self.headers = headers
}

type Response struct {
	socket        net.Conn
	version       string
	lockedStatus  bool
	lockedHeaders bool
}

// Send the status.
//
// This will lock the status, which makes it
// so that the next time you invoke this
// function it will return an error.
//
// The message defaults to blank.
//
// If the message is left blank,
// an algorithm will try to
// populate it automatically according to the status code.
func status(self *Response, status int, message string) error {
	if self.lockedStatus {
		return errors.New("status is locked")
	}
	messageLocal := message
	self.lockedStatus = true
	if "" == messageLocal {
		switch status {
		case 100:
			messageLocal = "Continue"
		case 101:
			messageLocal = "Switching Protocols"
		case 102:
			messageLocal = "Processing"
		case 103:
			messageLocal = "Early Hints"
		case 200:
			messageLocal = "OK"
		case 201:
			messageLocal = "Created"
		case 202:
			messageLocal = "Accepted"
		case 203:
			messageLocal = "Non-Authoritative Information"
		case 204:
			messageLocal = "No Content"
		case 205:
			messageLocal = "Reset Content"
		case 206:
			messageLocal = "Partial Content"
		case 207:
			messageLocal = "Multi-Status"
		case 208:
			messageLocal = "Already Reported"
		case 226:
			messageLocal = "IM Used"
		case 300:
			messageLocal = "Multiple Choices"
		case 301:
			messageLocal = "Moved Permanently"
		case 302:
			messageLocal = "Found"
		case 303:
			messageLocal = "See Other"
		case 304:
			messageLocal = "Not Modified"
		case 305:
			messageLocal = "Use Proxy"
		case 307:
			messageLocal = "Temporary Redirect"
		case 308:
			messageLocal = "Permanent Redirect"
		case 400:
			messageLocal = "Bad Request"
		case 401:
			messageLocal = "Unauthorized"
		case 402:
			messageLocal = "Payment Required"
		case 403:
			messageLocal = "Forbidden"
		case 404:
			messageLocal = "Not Found"
		case 405:
			messageLocal = "Method Not Allowed"
		case 406:
			messageLocal = "Not Acceptable"
		case 407:
			messageLocal = "Proxy Authentication Required"
		case 408:
			messageLocal = "Request Timeout"
		case 409:
			messageLocal = "Conflict"
		case 410:
			messageLocal = "Gone"
		case 411:
			messageLocal = "Length Required"
		case 412:
			messageLocal = "Precondition Failed"
		case 413:
			messageLocal = "Payload Too Large"
		case 414:
			messageLocal = "URI Too Long"
		case 415:
			messageLocal = "Unsupported Media Type"
		case 416:
			messageLocal = "Range Not Satisfiable"
		case 417:
			messageLocal = "Expectation Failed"
		case 421:
			messageLocal = "Misdirected Request"
		case 422:
			messageLocal = "Unprocessable Entity"
		case 423:
			messageLocal = "Locked"
		case 424:
			messageLocal = "Failed Dependency"
		case 426:
			messageLocal = "Upgrade Required"
		case 428:
			messageLocal = "Precondition Required"
		case 429:
			messageLocal = "Too Many Requests"
		case 431:
			messageLocal = "Request Header Fields Too Large"
		case 451:
			messageLocal = "Unavailable For Legal Reasons"
		case 500:
			messageLocal = "Internal Server Error"
		case 501:
			messageLocal = "Not Implemented"
		case 502:
			messageLocal = "Bad Gateway"
		case 503:
			messageLocal = "Service Unavailable"
		case 504:
			messageLocal = "Gateway Timeout"
		case 505:
			messageLocal = "HTTP Version Not Supported"
		case 506:
			messageLocal = "Variant Also Negotiates"
		case 507:
			messageLocal = "Insufficient Storage"
		case 508:
			messageLocal = "Loop Detected"
		case 510:
			messageLocal = "Not Extended"
		case 511:
			messageLocal = "Network Authentication Required"
		default:
			messageLocal = ""
		}
		if "" == messageLocal {
			return errors.New("unknown status code")
		}
	}
	feed := fmt.Sprintf("%s %d %s", self.version, status, message)
	_, err := self.socket.Write([]byte(feed))
	if err != nil {
		return err
	}
	return nil
}

// Send a header.
//
// If the status has not been sent already, it will be
// This means the status will become locked.
func header(self *Response, key string, value string) error {
	if !self.lockedStatus {
		err := status(self, 200, "OK")
		if err != nil {
			return err
		}
	}

	if self.lockedHeaders {
		return errors.New("headers locked")
	}

	_, err := self.socket.Write([]byte("\n" + key + ": " + value))
	if err != nil {
		return err
	}

	return nil
}

// Send binary safe content.
//
// If the status has not been sent already, it will be sent automatically as "200 OK".
// This means the status will become locked, meaning you cannot set it again.
//
// Headers will be automatically locked, meaning you can no longer set Headers after invoking this function.
func send(self *Response, value []byte) error {
	if !self.lockedStatus {
		err := status(self, 200, "OK")
		if err != nil {
			return err
		}
	}

	if !self.lockedHeaders {
		self.lockedHeaders = true
		_, err := self.socket.Write([]byte("\n\n"))
		if err != nil {
			return err
		}
	}

	_, err := self.socket.Write(value)
	if err != nil {
		return err
	}

	return nil
}

// Send utf8 content.
//
// If the status has not been sent already, it will be sent automatically as "200 OK".
// This means the status will become locked, meaning you cannot set it again.
//
// Headers will be automatically locked, meaning you can no longer set Headers after invoking this function.
func echo(self *Response, value string) error {
	return send(self, []byte(value))
}
